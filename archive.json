{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-05-11T01:21:15.508368+00:00",
  "repo": "sprangerik/frame-acknowledgement",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOOIDm-M6uhBeo",
      "title": "Some opens about the avtcore-frame-acknowledgement draft proposal",
      "url": "https://github.com/sprangerik/frame-acknowledgement/issues/1",
      "state": "OPEN",
      "author": "taste1981",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hi,\n\nI read the avtcore-frame-acknowledgement document, and I have a few questions:\n\n1.\tIf the request for a frame is sent, and receiver has already decoded corresponding frame, but subsequent decoding error happens and receiver decides to flush the decode picture buffers(DPB) before it acks the request. Should receiver still send the ACK?\n\n2.\tFor uniquely identifying a frame, should we always rely on existence of DD for this? Or we should rely on some more generic frame markers? Or this can be from application\n\n3.\tAny consideration why we do not use timestamp instead?\n\n4.\tIn the context of SFU/MCU, where you have 1 sender and multiple receivers, how would you expect those feedbacks to be routed and handled by sender?\n\nRegards\nJohnny\n",
      "createdAt": "2025-03-18T10:04:58Z",
      "updatedAt": "2025-04-07T15:04:27Z",
      "closedAt": null,
      "comments": [
        {
          "author": "sprangerik",
          "authorAssociation": "OWNER",
          "body": "1. I think it should respond, though in practice it won't really matter. If a receiver has a failure of that type, it will need to send a keyframe request to recover anyway.\n2.  The idea is that we have a prioritized list of identification methods, and we pick the first available one. DD is relatively straightforward so I added that as a startpoint. I'll open a separate issue on this topic, because I'm starting to doubt it's the right choice.\n3. Timestamps alone are not enough, it would need to be at least timestamp + spatial index (which might not be easily available). With the timestamp scale being 90kHz we'd also need a rather large data type to avoid potential wraparound issues.\n4. For and SFU/SFM I don't really see an option other than to ack only those frames acked by _all_ receivers for which that frame has been forwarded. For an MCU however, the uplink can be considered a separate point-to-point connection and then it's kind up to the encode/send part of the server to be designed in a way that makes sense for its application. The receivers will just blindly ack anything they decode.",
          "createdAt": "2025-04-07T15:04:26Z",
          "updatedAt": "2025-04-07T15:04:26Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "I_kwDOOIDm-M6xdT2w",
      "title": "Add a better definition of what a \"frame\" is",
      "url": "https://github.com/sprangerik/frame-acknowledgement/issues/2",
      "state": "OPEN",
      "author": "sprangerik",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "The current draft says that what is being acknowledged is that \"video frames have been received and decoded\", but we should probably be more precise what we mean with a frame.\n\nFor the context of this message, what we are interested in is that the sender can reason about the codec state. A potential phrasing could be the we acknowledge:\n\n> ...any decodable unit of bitstream data that results in the update of codec state (e.g. reference buffers, entropy tables, etc) that can be used as a reference for any subsequent decodable unit of bitstream data.\n\nWhen using SVC with inter-layer dependencies (i.e. references between e.g. spatial or quality layers), then each layer would constitute a separate frame. That seems relatively straightforward.\n\nHowever, several codecs support _segmentation_ where a frame is split into several independent segments in order to better utilize pipelining or parallelism. If such a segment supports referencing state updates from a different segment within the same frame - then in this case each segment could in fact be acked independently. This would complicate the frame id mechanism as well.\n\n",
      "createdAt": "2025-04-07T15:31:42Z",
      "updatedAt": "2025-04-07T15:31:42Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 3,
      "id": "I_kwDOOIDm-M6xdWlh",
      "title": "Consider supporting acknowledgement of received but not decoded frames",
      "url": "https://github.com/sprangerik/frame-acknowledgement/issues/3",
      "state": "OPEN",
      "author": "sprangerik",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "The current text talks only about acking frames that have been received with a guarantee that the receiver will _attempt_ to decode it.\n\nA natural question is if there is value in also acknowledging that a frames has been received - but might _not_ be used for decoding (e.g. non-base layer temporal frames).\n\nSince this message is primarily designed to allow a sender to reason about the decoder state, this doesn't at first glance seem that useful. But it would be good to know if someone has a valid use, or else just document why this is _not_ included.",
      "createdAt": "2025-04-07T15:35:10Z",
      "updatedAt": "2025-04-22T11:57:29Z",
      "closedAt": null,
      "comments": [
        {
          "author": "shrim27",
          "authorAssociation": "NONE",
          "body": "Can we consider extending status field to indicate \n0 = Not received (may be split partially received, fully lost frame)\n1 = Received, not decoded (completely assembled and submitted to decode)\n2 = decoded \n3 = decode error\nIn case of decode error, PLI request would be sent but sender does not understand why PLI was issued. Decode error info is useful for sender to help adapt for certain clients/decoder.\nI feel more info sender has it can act better.",
          "createdAt": "2025-04-14T06:23:09Z",
          "updatedAt": "2025-04-14T06:23:09Z"
        },
        {
          "author": "sprangerik",
          "authorAssociation": "OWNER",
          "body": "I'm not really against it, but I'm trying to build a mental model of how it would actually be used/implemented.\n\nDo we need to distinguish between decoder errors that are \"recoverable\" or not? E.g. consider the cases where:\n1. A decoder returns an error code because the bitstream data is malformed and decoding of that frame could be completed. No internal state is updated and the decoder is still \"alive\" in the same state as before the decode call was made.\n2. A (presumably HW) decoder suffers some form of failure (e.g. OOM) and the entire decoder context is torn down and deallocated.\n\nThe first could be recovered from with a feedback. The second would necessitate a full keyframe.",
          "createdAt": "2025-04-15T12:14:42Z",
          "updatedAt": "2025-04-15T12:14:42Z"
        },
        {
          "author": "shrim27",
          "authorAssociation": "NONE",
          "body": "I believe decode errors triggers PLI requests that would make issuing IDR frame. Having decode status in feedback helps sender take actions if LTR frame decode was successful or triggered error. Sender is aware of frames sent so that it can correct in case there are any faulty decoder exists. At this point I am not sure we need to distinguish decode errors. If there are more cases to be covered, dont see problem expanding decode error status.",
          "createdAt": "2025-04-21T21:18:57Z",
          "updatedAt": "2025-04-21T21:18:57Z"
        },
        {
          "author": "sprangerik",
          "authorAssociation": "OWNER",
          "body": "> I believe decode errors triggers PLI requests that would make issuing IDR frame.\n\nIfaik, PLI isn't explicitly intended as a keyframe request (even if that is how libwebrtc currently uses it). Rather it's what is call, a \"picture loss indication\" and it should be up to the receiver to deal with that loss. FIR is strictly a keyframe request however.\n\nI'm still not entirely convinced there are realistic cases where all of the following are true:\n\n1. The jitter buffer logic determines frame A is decodable\n2. The decoder despite that fails to decode frame A\n3. The decoder is still in a usable state and _can_ successfully decode a new frame, using previous state as reference.\n\nIn my experience, decode errors are very rare - and once they occur the decoder is essentially in an unknown state and needs to be reset anyway.\n\nDo you have any data to the contrary?",
          "createdAt": "2025-04-22T11:57:28Z",
          "updatedAt": "2025-04-22T11:57:28Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDOOIDm-M6xdeQg",
      "title": "Consider adding explicit frame id to the Frame Acknowledgement Request header",
      "url": "https://github.com/sprangerik/frame-acknowledgement/issues/4",
      "state": "OPEN",
      "author": "sprangerik",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "The current text does not specify how a frame should be identified - instead there is a prioritized list of alternatives for identifying frames, and the first available one on the list should be used. There are some pros and cons to this:\n\nPros\n* Avoids redundant frame id if it's already part of the transmission\n* Makes the request header itself very simple\n\nCons\n* Risk that the mechanism is fragile (e.g. if sender/receiver has different views of which id is in fact being used). Though this could be mitigated with an additional SDP attribute.\n* Some id mechanism requires tuples (e.g. timestamp + spatial layer, or even subindexing into segments).\n* Some mechanism have data in the payload, which might not be available to an SFU/SFM.\n* Some mechanism have large gaps between frames (e.g. using 90kHz clock timestamps), necessitating larger than desired sizes of the id fields in order to avoid wraparound issues.\n* A sender might only be interested in a small subset of frames, an generic id mechanisms will typically identify all frames - requiring status to be transmitted for \"uninteresting\" frames as well, in case a span of more than one frame is being inquired about.\n\nTo avoid the quite large list of cons, it might be desirable to explicitly identify the frames as part of the Frame Acknowledgement Request header extension instead. It should solve all of the cons with a relatively low overhead of extra data and slightly more complex parsing of the header.",
      "createdAt": "2025-04-07T15:47:00Z",
      "updatedAt": "2025-04-15T11:55:32Z",
      "closedAt": null,
      "comments": [
        {
          "author": "alfredh",
          "authorAssociation": "NONE",
          "body": "Another way to encode it could be to include number of frames to report in the header,\nfor example: uint8_t count\n\nThe base frame id could be the one from DD header, and count could be number of frames before that.\n",
          "createdAt": "2025-04-14T10:33:09Z",
          "updatedAt": "2025-04-14T10:33:09Z"
        },
        {
          "author": "sprangerik",
          "authorAssociation": "OWNER",
          "body": "I'm not sure I like the offset counter for the frame id itself, but a count would indeed feel nicer than the absolute \"to\" I mention in https://github.com/sprangerik/frame-acknowledgement/issues/5",
          "createdAt": "2025-04-15T11:55:30Z",
          "updatedAt": "2025-04-15T11:55:30Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDOOIDm-M6xdhyQ",
      "title": "Consider add a \"to\" field in the request header",
      "url": "https://github.com/sprangerik/frame-acknowledgement/issues/5",
      "state": "OPEN",
      "author": "sprangerik",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "The current text specified that the Frame Acknowledgement Request has the property that it \"...implies a status request for all frames starting at the given frame ID, up to and including the frame contained in the RTP packet the header extension is attached to...\".\n\nThe sender might in fact not be interested in all those frames - it might just be attempting to request a retransmit of the status for a single frame. For such use cases it would be useful with both a \"start\" and a \"end\" frame id, or potentially some type of flag that identified the id as both start and end if it's a single id.\n\nThis might complicate and enlarge the header extension, but also makes it more clear since there is no longer any ambiguity in what the end should be (if the packet it is attached to is not a frame).",
      "createdAt": "2025-04-07T15:51:57Z",
      "updatedAt": "2025-04-07T15:51:57Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 6,
      "id": "I_kwDOOIDm-M6yVrJC",
      "title": "SDP to negotiate RTP extension",
      "url": "https://github.com/sprangerik/frame-acknowledgement/issues/6",
      "state": "OPEN",
      "author": "shrim27",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Should RFC include SDP syntax for defining SDP extension header ID. Probably RFC URL can be used to define extension type.",
      "createdAt": "2025-04-14T06:30:30Z",
      "updatedAt": "2025-04-15T11:53:06Z",
      "closedAt": null,
      "comments": [
        {
          "author": "sprangerik",
          "authorAssociation": "OWNER",
          "body": "Yes, that's a good point. We should also add SDP considerations for the RTCP message.",
          "createdAt": "2025-04-15T11:53:04Z",
          "updatedAt": "2025-04-15T11:53:04Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDOOIDm-M6yVs1C",
      "title": "Frame acknowledgment request on recovered packets",
      "url": "https://github.com/sprangerik/frame-acknowledgement/issues/7",
      "state": "OPEN",
      "author": "shrim27",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Does the draft need to explain how acknowledgment request on recovered packet be addressed. Ex: Nack or FEC recovered packet might have frame acknowledgement request, does receiver need to handle them same way as original request or neglect them.\nI think considering them as original probably is better way, not sure you have any considerations.",
      "createdAt": "2025-04-14T06:33:51Z",
      "updatedAt": "2025-04-15T11:51:01Z",
      "closedAt": null,
      "comments": [
        {
          "author": "sprangerik",
          "authorAssociation": "OWNER",
          "body": "Good point, this should be clearly specified.\n\nI think a reasonable action would be to treat them as original - unless a later feedback request has already been processed, in which case it should be ignored. The same point should hold for any case where there is packet reordering.",
          "createdAt": "2025-04-15T11:51:00Z",
          "updatedAt": "2025-04-15T11:51:00Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDOOIDm-M6yVyPd",
      "title": "Receiver triggered Frame acknowledgement",
      "url": "https://github.com/sprangerik/frame-acknowledgement/issues/8",
      "state": "OPEN",
      "author": "shrim27",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Current format is using request-based approach, keeping receiver dumb as much as possible. There is a advantage in having receiver triggered feedback, sender request could be overhead which may not be necessary for certain applications. \nSDP format can be added to distinguish between different modes such that application developer can choose what fits best. \nFeedback mainly helps under packet loss, and providing configuration like trigger feedback if no fresh frame is submitted to decoder for 'x' timeout time and retrigger it every new frame received but cant be submitted to decode since packet loss has not resolved. These help receiver recover faster rather than wait for new feedback request from sender.",
      "createdAt": "2025-04-14T06:45:26Z",
      "updatedAt": "2025-04-22T13:28:50Z",
      "closedAt": null,
      "comments": [
        {
          "author": "sprangerik",
          "authorAssociation": "OWNER",
          "body": "That might be interesting, although I feel like packet-level feedback (e.g. TWCC or RFC8888) might already be enough.\n\nIf we were to support receive-side initiated feedback, it could interfere with the mechanism which describes which frames states the receiver needs to keep track of. It might be that in this case we need mark the feedback as being out of bounds with respect to the requested feedback.\n",
          "createdAt": "2025-04-15T11:48:00Z",
          "updatedAt": "2025-04-15T11:48:00Z"
        },
        {
          "author": "shrim27",
          "authorAssociation": "NONE",
          "body": "Problem with using (TWCC or RFC 8888) is they dont provide current frame serviced by decoder hence it not very useful for LTR during packet loss.\nFor cases where RTD is high, sender requested feedback is very delayed and can lead to big impacts on decoder recovery time. Hence proposing having mode where receiver can trigger the feedback.\nWe could negotiate mode using SDP also RTCP message can have flag to indicate sender requested or receiver generated to distinguish, so that there is less for interpretation.\nIn terms of frames to keep track of I was suggesting interval can be defined, (Ex:  similar to \"rtx-time=\" ) shared details in another thread. Feedback could include highest frameID decoded to highest frame-ID received.",
          "createdAt": "2025-04-21T21:10:32Z",
          "updatedAt": "2025-04-21T21:10:32Z"
        },
        {
          "author": "sprangerik",
          "authorAssociation": "OWNER",
          "body": "The request shouldn't be delayed. If the sender knows it wants feedback for a given frame N (e.g. because it has been assigned as an LTR frame), the sender will add the request header extension to the very packets containing the payload data for frame N - so that the receiver can send feedback as soon as the frame has been assembled.\n\nIf we add a status symbol for \"frame partially received\", that could be sent immediately to notify the sender so that it can determine which recovery method to use for recovery (e.g. FEC/RTX/LTR/etc)\n\nMaybe it would help if we had concrete examples.\n\nwdyt?",
          "createdAt": "2025-04-22T13:28:50Z",
          "updatedAt": "2025-04-22T13:28:50Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "I_kwDOOIDm-M6yV14_",
      "title": "Mechanism to decode LTR frame",
      "url": "https://github.com/sprangerik/frame-acknowledgement/issues/9",
      "state": "OPEN",
      "author": "shrim27",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Not sure this is relevant for draft but in general how do you think frame assembly would work with frame encoded using LTR frame.\nAs per my understanding webrtc currently waits for packet loss to recover or IDR frame to arrive for unblocking frames received to start decoding.\nWith frame acknowledgment, no longer need to wait for IDR, do you think webrtc frame assembly need to change and what information is needed for it handle this new feature? I think DD extension has mechanisms defined which could be useful here. Checking if there is any thoughts on this.",
      "createdAt": "2025-04-14T06:53:25Z",
      "updatedAt": "2025-04-22T12:50:34Z",
      "closedAt": null,
      "comments": [
        {
          "author": "sprangerik",
          "authorAssociation": "OWNER",
          "body": "I don't think the receiver logic needs any update. At least in libwebrtc, the video jitter buffer looks at the dependency chain and waits for frames to be decodable - it doesn't really distinguish between recovery via retransmissions, fec, or new frames with dependencies on received frames.\n\nWe also don't really care if the dependencies are described via DependecyDescriptors, FrameMarking or one of the older payload-specific formats.\n\nIn essence, recover via LTR isn't different from say temporal layering and fast-forwarding to the next TL0 frame if one or more upper-layer frames have become stalled.",
          "createdAt": "2025-04-15T11:41:27Z",
          "updatedAt": "2025-04-15T11:41:27Z"
        },
        {
          "author": "shrim27",
          "authorAssociation": "NONE",
          "body": "Thanks Erik, if you could point to libwebrtc code where its handled would be helpful.",
          "createdAt": "2025-04-18T04:51:36Z",
          "updatedAt": "2025-04-18T04:51:36Z"
        },
        {
          "author": "sprangerik",
          "authorAssociation": "OWNER",
          "body": "> Thanks Erik, if you could point to libwebrtc code where its handled would be helpful.\n\nThe code is spread out across a number of classes, but in general is coordinated by this one: https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/video/rtp_video_stream_receiver2.h",
          "createdAt": "2025-04-22T12:50:33Z",
          "updatedAt": "2025-04-22T12:50:33Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDOOIDm-M6ylyIP",
      "title": "Consider if we need a way to signal \"not interest in feedback for frames prior to X\"",
      "url": "https://github.com/sprangerik/frame-acknowledgement/issues/10",
      "state": "OPEN",
      "author": "sprangerik",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "The current proposal specifies that \"If a new Frame Acknowledgement Request is sent with an incremented Frame ID, all status values prior to that Frame ID are considered as acknowledged and can be culled by the receiver. \".\n\nHowever, a situation could feasibly arise where a sender does not request feedback for an extended period of time simply because it is not interested in feedback at that time. The receiver cannot know that and must thus keep buffering frame states, possibly indefinitely.\n\nA workaround is to require the sender to request feedback with some interval, and it would then simply ignore the feedback.\n\nIt would be nicer if we had a way to signal that the sender is not interested in feedback prior to frame X, all such state can be culled, and no immediate feedback is requested.",
      "createdAt": "2025-04-15T12:24:30Z",
      "updatedAt": "2025-04-15T16:23:45Z",
      "closedAt": null,
      "comments": [
        {
          "author": "shrim27",
          "authorAssociation": "NONE",
          "body": "Something similar to \"rtx-time=<rtx-time-val>\" defined rfc4588 could be used as reference here.",
          "createdAt": "2025-04-15T16:23:44Z",
          "updatedAt": "2025-04-15T16:23:44Z"
        }
      ]
    }
  ],
  "pulls": []
}